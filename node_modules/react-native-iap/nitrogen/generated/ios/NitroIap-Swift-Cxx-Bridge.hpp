///
/// NitroIap-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `HybridRnIapSpec` to properly resolve imports.
namespace margelo::nitro::iap { class HybridRnIapSpec; }
// Forward declaration of `IapPlatform` to properly resolve imports.
namespace margelo::nitro::iap { enum class IapPlatform; }
// Forward declaration of `NitroAvailablePurchasesAndroidOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroAvailablePurchasesAndroidOptions; }
// Forward declaration of `NitroAvailablePurchasesIosOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroAvailablePurchasesIosOptions; }
// Forward declaration of `NitroAvailablePurchasesOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroAvailablePurchasesOptions; }
// Forward declaration of `NitroFinishTransactionAndroidParams` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroFinishTransactionAndroidParams; }
// Forward declaration of `NitroFinishTransactionIosParams` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroFinishTransactionIosParams; }
// Forward declaration of `NitroProduct` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroProduct; }
// Forward declaration of `NitroPurchaseResult` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroPurchaseResult; }
// Forward declaration of `NitroPurchase` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroPurchase; }
// Forward declaration of `NitroReceiptValidationAndroidOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationAndroidOptions; }
// Forward declaration of `NitroReceiptValidationResultAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationResultAndroid; }
// Forward declaration of `NitroReceiptValidationResultIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationResultIOS; }
// Forward declaration of `NitroRequestPurchaseAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroRequestPurchaseAndroid; }
// Forward declaration of `NitroRequestPurchaseIos` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroRequestPurchaseIos; }
// Forward declaration of `NitroSubscriptionOffer` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroSubscriptionOffer; }
// Forward declaration of `NitroSubscriptionRenewalInfo` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroSubscriptionRenewalInfo; }
// Forward declaration of `NitroSubscriptionStatus` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroSubscriptionStatus; }
// Forward declaration of `PurchaseAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct PurchaseAndroid; }
// Forward declaration of `PurchaseIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct PurchaseIOS; }
// Forward declaration of `PurchaseOfferIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct PurchaseOfferIOS; }
// Forward declaration of `PurchaseState` to properly resolve imports.
namespace margelo::nitro::iap { enum class PurchaseState; }
// Forward declaration of `RequestPurchaseResult` to properly resolve imports.
namespace margelo::nitro::iap { struct RequestPurchaseResult; }

// Forward declarations of Swift defined types
// Forward declaration of `HybridRnIapSpec_cxx` to properly resolve imports.
namespace NitroIap { class HybridRnIapSpec_cxx; }

// Include C++ defined types
#include "HybridRnIapSpec.hpp"
#include "IapPlatform.hpp"
#include "NitroAvailablePurchasesAndroidOptions.hpp"
#include "NitroAvailablePurchasesIosOptions.hpp"
#include "NitroAvailablePurchasesOptions.hpp"
#include "NitroFinishTransactionAndroidParams.hpp"
#include "NitroFinishTransactionIosParams.hpp"
#include "NitroProduct.hpp"
#include "NitroPurchase.hpp"
#include "NitroPurchaseResult.hpp"
#include "NitroReceiptValidationAndroidOptions.hpp"
#include "NitroReceiptValidationResultAndroid.hpp"
#include "NitroReceiptValidationResultIOS.hpp"
#include "NitroRequestPurchaseAndroid.hpp"
#include "NitroRequestPurchaseIos.hpp"
#include "NitroSubscriptionOffer.hpp"
#include "NitroSubscriptionRenewalInfo.hpp"
#include "NitroSubscriptionStatus.hpp"
#include "PurchaseAndroid.hpp"
#include "PurchaseIOS.hpp"
#include "PurchaseOfferIOS.hpp"
#include "PurchaseState.hpp"
#include "RequestPurchaseResult.hpp"
#include <NitroModules/Promise.hpp>
#include <NitroModules/PromiseHolder.hpp>
#include <NitroModules/Result.hpp>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <variant>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::iap::bridge::swift {

  // pragma MARK: std::shared_ptr<Promise<bool>>
  /**
   * Specialized version of `std::shared_ptr<Promise<bool>>`.
   */
  using std__shared_ptr_Promise_bool__ = std::shared_ptr<Promise<bool>>;
  inline std::shared_ptr<Promise<bool>> create_std__shared_ptr_Promise_bool__() noexcept {
    return Promise<bool>::create();
  }
  inline PromiseHolder<bool> wrap_std__shared_ptr_Promise_bool__(std::shared_ptr<Promise<bool>> promise) noexcept {
    return PromiseHolder<bool>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(bool /* result */)>
  /**
   * Specialized version of `std::function<void(bool)>`.
   */
  using Func_void_bool = std::function<void(bool /* result */)>;
  /**
   * Wrapper class for a `std::function<void(bool / * result * /)>`, this can be used from Swift.
   */
  class Func_void_bool_Wrapper final {
  public:
    explicit Func_void_bool_Wrapper(std::function<void(bool /* result */)>&& func): _function(std::make_unique<std::function<void(bool /* result */)>>(std::move(func))) {}
    inline void call(bool result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(bool /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_bool create_Func_void_bool(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_bool_Wrapper wrap_Func_void_bool(Func_void_bool value) noexcept {
    return Func_void_bool_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const std::exception_ptr& /* error */)>
  /**
   * Specialized version of `std::function<void(const std::exception_ptr&)>`.
   */
  using Func_void_std__exception_ptr = std::function<void(const std::exception_ptr& /* error */)>;
  /**
   * Wrapper class for a `std::function<void(const std::exception_ptr& / * error * /)>`, this can be used from Swift.
   */
  class Func_void_std__exception_ptr_Wrapper final {
  public:
    explicit Func_void_std__exception_ptr_Wrapper(std::function<void(const std::exception_ptr& /* error */)>&& func): _function(std::make_unique<std::function<void(const std::exception_ptr& /* error */)>>(std::move(func))) {}
    inline void call(std::exception_ptr error) const noexcept {
      _function->operator()(error);
    }
  private:
    std::unique_ptr<std::function<void(const std::exception_ptr& /* error */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__exception_ptr create_Func_void_std__exception_ptr(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_std__exception_ptr_Wrapper wrap_Func_void_std__exception_ptr(Func_void_std__exception_ptr value) noexcept {
    return Func_void_std__exception_ptr_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::string>
  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) noexcept {
    return std::optional<std::string>(value);
  }
  inline bool has_value_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return optional.has_value();
  }
  inline std::string get_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<double>
  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) noexcept {
    return std::optional<double>(value);
  }
  inline bool has_value_std__optional_double_(const std::optional<double>& optional) noexcept {
    return optional.has_value();
  }
  inline double get_std__optional_double_(const std::optional<double>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<bool>
  /**
   * Specialized version of `std::optional<bool>`.
   */
  using std__optional_bool_ = std::optional<bool>;
  inline std::optional<bool> create_std__optional_bool_(const bool& value) noexcept {
    return std::optional<bool>(value);
  }
  inline bool has_value_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return optional.has_value();
  }
  inline bool get_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroProduct>
  /**
   * Specialized version of `std::vector<NitroProduct>`.
   */
  using std__vector_NitroProduct_ = std::vector<NitroProduct>;
  inline std::vector<NitroProduct> create_std__vector_NitroProduct_(size_t size) noexcept {
    std::vector<NitroProduct> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<NitroProduct>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<NitroProduct>>>`.
   */
  using std__shared_ptr_Promise_std__vector_NitroProduct___ = std::shared_ptr<Promise<std::vector<NitroProduct>>>;
  inline std::shared_ptr<Promise<std::vector<NitroProduct>>> create_std__shared_ptr_Promise_std__vector_NitroProduct___() noexcept {
    return Promise<std::vector<NitroProduct>>::create();
  }
  inline PromiseHolder<std::vector<NitroProduct>> wrap_std__shared_ptr_Promise_std__vector_NitroProduct___(std::shared_ptr<Promise<std::vector<NitroProduct>>> promise) noexcept {
    return PromiseHolder<std::vector<NitroProduct>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<NitroProduct>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<NitroProduct>&)>`.
   */
  using Func_void_std__vector_NitroProduct_ = std::function<void(const std::vector<NitroProduct>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<NitroProduct>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_NitroProduct__Wrapper final {
  public:
    explicit Func_void_std__vector_NitroProduct__Wrapper(std::function<void(const std::vector<NitroProduct>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<NitroProduct>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<NitroProduct> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<NitroProduct>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_NitroProduct_ create_Func_void_std__vector_NitroProduct_(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_NitroProduct__Wrapper wrap_Func_void_std__vector_NitroProduct_(Func_void_std__vector_NitroProduct_ value) noexcept {
    return Func_void_std__vector_NitroProduct__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<std::string>
  /**
   * Specialized version of `std::vector<std::string>`.
   */
  using std__vector_std__string_ = std::vector<std::string>;
  inline std::vector<std::string> create_std__vector_std__string_(size_t size) noexcept {
    std::vector<std::string> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<std::string>>
  /**
   * Specialized version of `std::optional<std::vector<std::string>>`.
   */
  using std__optional_std__vector_std__string__ = std::optional<std::vector<std::string>>;
  inline std::optional<std::vector<std::string>> create_std__optional_std__vector_std__string__(const std::vector<std::string>& value) noexcept {
    return std::optional<std::vector<std::string>>(value);
  }
  inline bool has_value_std__optional_std__vector_std__string__(const std::optional<std::vector<std::string>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<std::string> get_std__optional_std__vector_std__string__(const std::optional<std::vector<std::string>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PurchaseOfferIOS>
  /**
   * Specialized version of `std::optional<PurchaseOfferIOS>`.
   */
  using std__optional_PurchaseOfferIOS_ = std::optional<PurchaseOfferIOS>;
  inline std::optional<PurchaseOfferIOS> create_std__optional_PurchaseOfferIOS_(const PurchaseOfferIOS& value) noexcept {
    return std::optional<PurchaseOfferIOS>(value);
  }
  inline bool has_value_std__optional_PurchaseOfferIOS_(const std::optional<PurchaseOfferIOS>& optional) noexcept {
    return optional.has_value();
  }
  inline PurchaseOfferIOS get_std__optional_PurchaseOfferIOS_(const std::optional<PurchaseOfferIOS>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<PurchaseAndroid, PurchaseIOS>
  /**
   * Wrapper struct for `std::variant<PurchaseAndroid, PurchaseIOS>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_PurchaseAndroid__PurchaseIOS_ {
    std::variant<PurchaseAndroid, PurchaseIOS> variant;
    std__variant_PurchaseAndroid__PurchaseIOS_(std::variant<PurchaseAndroid, PurchaseIOS> variant): variant(variant) { }
    operator std::variant<PurchaseAndroid, PurchaseIOS>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline PurchaseAndroid get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline PurchaseIOS get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_PurchaseAndroid__PurchaseIOS_ create_std__variant_PurchaseAndroid__PurchaseIOS_(const PurchaseAndroid& value) noexcept {
    return std__variant_PurchaseAndroid__PurchaseIOS_(value);
  }
  inline std__variant_PurchaseAndroid__PurchaseIOS_ create_std__variant_PurchaseAndroid__PurchaseIOS_(const PurchaseIOS& value) noexcept {
    return std__variant_PurchaseAndroid__PurchaseIOS_(value);
  }
  
  // pragma MARK: std::optional<std::variant<PurchaseAndroid, PurchaseIOS>>
  /**
   * Specialized version of `std::optional<std::variant<PurchaseAndroid, PurchaseIOS>>`.
   */
  using std__optional_std__variant_PurchaseAndroid__PurchaseIOS__ = std::optional<std::variant<PurchaseAndroid, PurchaseIOS>>;
  inline std::optional<std::variant<PurchaseAndroid, PurchaseIOS>> create_std__optional_std__variant_PurchaseAndroid__PurchaseIOS__(const std::variant<PurchaseAndroid, PurchaseIOS>& value) noexcept {
    return std::optional<std::variant<PurchaseAndroid, PurchaseIOS>>(value);
  }
  inline bool has_value_std__optional_std__variant_PurchaseAndroid__PurchaseIOS__(const std::optional<std::variant<PurchaseAndroid, PurchaseIOS>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::variant<PurchaseAndroid, PurchaseIOS> get_std__optional_std__variant_PurchaseAndroid__PurchaseIOS__(const std::optional<std::variant<PurchaseAndroid, PurchaseIOS>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>
  /**
   * Specialized version of `std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>`.
   */
  using std__vector_std__variant_PurchaseAndroid__PurchaseIOS__ = std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>;
  inline std::vector<std::variant<PurchaseAndroid, PurchaseIOS>> create_std__vector_std__variant_PurchaseAndroid__PurchaseIOS__(size_t size) noexcept {
    std::vector<std::variant<PurchaseAndroid, PurchaseIOS>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>
  /**
   * Specialized version of `std::optional<std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>`.
   */
  using std__optional_std__vector_std__variant_PurchaseAndroid__PurchaseIOS___ = std::optional<std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>;
  inline std::optional<std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>> create_std__optional_std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(const std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>& value) noexcept {
    return std::optional<std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>(value);
  }
  inline bool has_value_std__optional_std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(const std::optional<std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<std::variant<PurchaseAndroid, PurchaseIOS>> get_std__optional_std__vector_std__variant_PurchaseAndroid__PurchaseIOS___(const std::optional<std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<Promise<RequestPurchaseResult>>
  /**
   * Specialized version of `std::shared_ptr<Promise<RequestPurchaseResult>>`.
   */
  using std__shared_ptr_Promise_RequestPurchaseResult__ = std::shared_ptr<Promise<RequestPurchaseResult>>;
  inline std::shared_ptr<Promise<RequestPurchaseResult>> create_std__shared_ptr_Promise_RequestPurchaseResult__() noexcept {
    return Promise<RequestPurchaseResult>::create();
  }
  inline PromiseHolder<RequestPurchaseResult> wrap_std__shared_ptr_Promise_RequestPurchaseResult__(std::shared_ptr<Promise<RequestPurchaseResult>> promise) noexcept {
    return PromiseHolder<RequestPurchaseResult>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const RequestPurchaseResult& /* result */)>
  /**
   * Specialized version of `std::function<void(const RequestPurchaseResult&)>`.
   */
  using Func_void_RequestPurchaseResult = std::function<void(const RequestPurchaseResult& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const RequestPurchaseResult& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_RequestPurchaseResult_Wrapper final {
  public:
    explicit Func_void_RequestPurchaseResult_Wrapper(std::function<void(const RequestPurchaseResult& /* result */)>&& func): _function(std::make_unique<std::function<void(const RequestPurchaseResult& /* result */)>>(std::move(func))) {}
    inline void call(RequestPurchaseResult result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const RequestPurchaseResult& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_RequestPurchaseResult create_Func_void_RequestPurchaseResult(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_RequestPurchaseResult_Wrapper wrap_Func_void_RequestPurchaseResult(Func_void_RequestPurchaseResult value) noexcept {
    return Func_void_RequestPurchaseResult_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::unordered_map<std::string, std::string>
  /**
   * Specialized version of `std::unordered_map<std::string, std::string>`.
   */
  using std__unordered_map_std__string__std__string_ = std::unordered_map<std::string, std::string>;
  inline std::unordered_map<std::string, std::string> create_std__unordered_map_std__string__std__string_(size_t size) noexcept {
    std::unordered_map<std::string, std::string> map;
    map.reserve(size);
    return map;
  }
  inline std::vector<std::string> get_std__unordered_map_std__string__std__string__keys(const std__unordered_map_std__string__std__string_& map) noexcept {
    std::vector<std::string> keys;
    keys.reserve(map.size());
    for (const auto& entry : map) {
      keys.push_back(entry.first);
    }
    return keys;
  }
  inline std::string get_std__unordered_map_std__string__std__string__value(const std__unordered_map_std__string__std__string_& map, const std::string& key) noexcept {
    return map.find(key)->second;
  }
  inline void emplace_std__unordered_map_std__string__std__string_(std__unordered_map_std__string__std__string_& map, const std::string& key, const std::string& value) noexcept {
    map.emplace(key, value);
  }
  
  // pragma MARK: std::optional<std::unordered_map<std::string, std::string>>
  /**
   * Specialized version of `std::optional<std::unordered_map<std::string, std::string>>`.
   */
  using std__optional_std__unordered_map_std__string__std__string__ = std::optional<std::unordered_map<std::string, std::string>>;
  inline std::optional<std::unordered_map<std::string, std::string>> create_std__optional_std__unordered_map_std__string__std__string__(const std::unordered_map<std::string, std::string>& value) noexcept {
    return std::optional<std::unordered_map<std::string, std::string>>(value);
  }
  inline bool has_value_std__optional_std__unordered_map_std__string__std__string__(const std::optional<std::unordered_map<std::string, std::string>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::unordered_map<std::string, std::string> get_std__optional_std__unordered_map_std__string__std__string__(const std::optional<std::unordered_map<std::string, std::string>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroRequestPurchaseIos>
  /**
   * Specialized version of `std::optional<NitroRequestPurchaseIos>`.
   */
  using std__optional_NitroRequestPurchaseIos_ = std::optional<NitroRequestPurchaseIos>;
  inline std::optional<NitroRequestPurchaseIos> create_std__optional_NitroRequestPurchaseIos_(const NitroRequestPurchaseIos& value) noexcept {
    return std::optional<NitroRequestPurchaseIos>(value);
  }
  inline bool has_value_std__optional_NitroRequestPurchaseIos_(const std::optional<NitroRequestPurchaseIos>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroRequestPurchaseIos get_std__optional_NitroRequestPurchaseIos_(const std::optional<NitroRequestPurchaseIos>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroSubscriptionOffer>
  /**
   * Specialized version of `std::vector<NitroSubscriptionOffer>`.
   */
  using std__vector_NitroSubscriptionOffer_ = std::vector<NitroSubscriptionOffer>;
  inline std::vector<NitroSubscriptionOffer> create_std__vector_NitroSubscriptionOffer_(size_t size) noexcept {
    std::vector<NitroSubscriptionOffer> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<NitroSubscriptionOffer>>
  /**
   * Specialized version of `std::optional<std::vector<NitroSubscriptionOffer>>`.
   */
  using std__optional_std__vector_NitroSubscriptionOffer__ = std::optional<std::vector<NitroSubscriptionOffer>>;
  inline std::optional<std::vector<NitroSubscriptionOffer>> create_std__optional_std__vector_NitroSubscriptionOffer__(const std::vector<NitroSubscriptionOffer>& value) noexcept {
    return std::optional<std::vector<NitroSubscriptionOffer>>(value);
  }
  inline bool has_value_std__optional_std__vector_NitroSubscriptionOffer__(const std::optional<std::vector<NitroSubscriptionOffer>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<NitroSubscriptionOffer> get_std__optional_std__vector_NitroSubscriptionOffer__(const std::optional<std::vector<NitroSubscriptionOffer>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroRequestPurchaseAndroid>
  /**
   * Specialized version of `std::optional<NitroRequestPurchaseAndroid>`.
   */
  using std__optional_NitroRequestPurchaseAndroid_ = std::optional<NitroRequestPurchaseAndroid>;
  inline std::optional<NitroRequestPurchaseAndroid> create_std__optional_NitroRequestPurchaseAndroid_(const NitroRequestPurchaseAndroid& value) noexcept {
    return std::optional<NitroRequestPurchaseAndroid>(value);
  }
  inline bool has_value_std__optional_NitroRequestPurchaseAndroid_(const std::optional<NitroRequestPurchaseAndroid>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroRequestPurchaseAndroid get_std__optional_NitroRequestPurchaseAndroid_(const std::optional<NitroRequestPurchaseAndroid>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroPurchase>
  /**
   * Specialized version of `std::vector<NitroPurchase>`.
   */
  using std__vector_NitroPurchase_ = std::vector<NitroPurchase>;
  inline std::vector<NitroPurchase> create_std__vector_NitroPurchase_(size_t size) noexcept {
    std::vector<NitroPurchase> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::vector<NitroPurchase>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::vector<NitroPurchase>>>`.
   */
  using std__shared_ptr_Promise_std__vector_NitroPurchase___ = std::shared_ptr<Promise<std::vector<NitroPurchase>>>;
  inline std::shared_ptr<Promise<std::vector<NitroPurchase>>> create_std__shared_ptr_Promise_std__vector_NitroPurchase___() noexcept {
    return Promise<std::vector<NitroPurchase>>::create();
  }
  inline PromiseHolder<std::vector<NitroPurchase>> wrap_std__shared_ptr_Promise_std__vector_NitroPurchase___(std::shared_ptr<Promise<std::vector<NitroPurchase>>> promise) noexcept {
    return PromiseHolder<std::vector<NitroPurchase>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::vector<NitroPurchase>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::vector<NitroPurchase>&)>`.
   */
  using Func_void_std__vector_NitroPurchase_ = std::function<void(const std::vector<NitroPurchase>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<NitroPurchase>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_NitroPurchase__Wrapper final {
  public:
    explicit Func_void_std__vector_NitroPurchase__Wrapper(std::function<void(const std::vector<NitroPurchase>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::vector<NitroPurchase>& /* result */)>>(std::move(func))) {}
    inline void call(std::vector<NitroPurchase> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<NitroPurchase>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_NitroPurchase_ create_Func_void_std__vector_NitroPurchase_(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_NitroPurchase__Wrapper wrap_Func_void_std__vector_NitroPurchase_(Func_void_std__vector_NitroPurchase_ value) noexcept {
    return Func_void_std__vector_NitroPurchase__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<NitroAvailablePurchasesIosOptions>
  /**
   * Specialized version of `std::optional<NitroAvailablePurchasesIosOptions>`.
   */
  using std__optional_NitroAvailablePurchasesIosOptions_ = std::optional<NitroAvailablePurchasesIosOptions>;
  inline std::optional<NitroAvailablePurchasesIosOptions> create_std__optional_NitroAvailablePurchasesIosOptions_(const NitroAvailablePurchasesIosOptions& value) noexcept {
    return std::optional<NitroAvailablePurchasesIosOptions>(value);
  }
  inline bool has_value_std__optional_NitroAvailablePurchasesIosOptions_(const std::optional<NitroAvailablePurchasesIosOptions>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroAvailablePurchasesIosOptions get_std__optional_NitroAvailablePurchasesIosOptions_(const std::optional<NitroAvailablePurchasesIosOptions>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroAvailablePurchasesAndroidOptions>
  /**
   * Specialized version of `std::optional<NitroAvailablePurchasesAndroidOptions>`.
   */
  using std__optional_NitroAvailablePurchasesAndroidOptions_ = std::optional<NitroAvailablePurchasesAndroidOptions>;
  inline std::optional<NitroAvailablePurchasesAndroidOptions> create_std__optional_NitroAvailablePurchasesAndroidOptions_(const NitroAvailablePurchasesAndroidOptions& value) noexcept {
    return std::optional<NitroAvailablePurchasesAndroidOptions>(value);
  }
  inline bool has_value_std__optional_NitroAvailablePurchasesAndroidOptions_(const std::optional<NitroAvailablePurchasesAndroidOptions>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroAvailablePurchasesAndroidOptions get_std__optional_NitroAvailablePurchasesAndroidOptions_(const std::optional<NitroAvailablePurchasesAndroidOptions>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroAvailablePurchasesOptions>
  /**
   * Specialized version of `std::optional<NitroAvailablePurchasesOptions>`.
   */
  using std__optional_NitroAvailablePurchasesOptions_ = std::optional<NitroAvailablePurchasesOptions>;
  inline std::optional<NitroAvailablePurchasesOptions> create_std__optional_NitroAvailablePurchasesOptions_(const NitroAvailablePurchasesOptions& value) noexcept {
    return std::optional<NitroAvailablePurchasesOptions>(value);
  }
  inline bool has_value_std__optional_NitroAvailablePurchasesOptions_(const std::optional<NitroAvailablePurchasesOptions>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroAvailablePurchasesOptions get_std__optional_NitroAvailablePurchasesOptions_(const std::optional<NitroAvailablePurchasesOptions>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::variant<bool, NitroPurchaseResult>
  /**
   * Wrapper struct for `std::variant<bool, NitroPurchaseResult>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_bool__NitroPurchaseResult_ {
    std::variant<bool, NitroPurchaseResult> variant;
    std__variant_bool__NitroPurchaseResult_(std::variant<bool, NitroPurchaseResult> variant): variant(variant) { }
    operator std::variant<bool, NitroPurchaseResult>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline bool get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroPurchaseResult get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_bool__NitroPurchaseResult_ create_std__variant_bool__NitroPurchaseResult_(bool value) noexcept {
    return std__variant_bool__NitroPurchaseResult_(value);
  }
  inline std__variant_bool__NitroPurchaseResult_ create_std__variant_bool__NitroPurchaseResult_(const NitroPurchaseResult& value) noexcept {
    return std__variant_bool__NitroPurchaseResult_(value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>`.
   */
  using std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult___ = std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>;
  inline std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>> create_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult___() noexcept {
    return Promise<std::variant<bool, NitroPurchaseResult>>::create();
  }
  inline PromiseHolder<std::variant<bool, NitroPurchaseResult>> wrap_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult___(std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>> promise) noexcept {
    return PromiseHolder<std::variant<bool, NitroPurchaseResult>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::variant<bool, NitroPurchaseResult>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::variant<bool, NitroPurchaseResult>&)>`.
   */
  using Func_void_std__variant_bool__NitroPurchaseResult_ = std::function<void(const std::variant<bool, NitroPurchaseResult>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::variant<bool, NitroPurchaseResult>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__variant_bool__NitroPurchaseResult__Wrapper final {
  public:
    explicit Func_void_std__variant_bool__NitroPurchaseResult__Wrapper(std::function<void(const std::variant<bool, NitroPurchaseResult>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::variant<bool, NitroPurchaseResult>& /* result */)>>(std::move(func))) {}
    inline void call(std::variant<bool, NitroPurchaseResult> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::variant<bool, NitroPurchaseResult>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__variant_bool__NitroPurchaseResult_ create_Func_void_std__variant_bool__NitroPurchaseResult_(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_std__variant_bool__NitroPurchaseResult__Wrapper wrap_Func_void_std__variant_bool__NitroPurchaseResult_(Func_void_std__variant_bool__NitroPurchaseResult_ value) noexcept {
    return Func_void_std__variant_bool__NitroPurchaseResult__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<NitroFinishTransactionIosParams>
  /**
   * Specialized version of `std::optional<NitroFinishTransactionIosParams>`.
   */
  using std__optional_NitroFinishTransactionIosParams_ = std::optional<NitroFinishTransactionIosParams>;
  inline std::optional<NitroFinishTransactionIosParams> create_std__optional_NitroFinishTransactionIosParams_(const NitroFinishTransactionIosParams& value) noexcept {
    return std::optional<NitroFinishTransactionIosParams>(value);
  }
  inline bool has_value_std__optional_NitroFinishTransactionIosParams_(const std::optional<NitroFinishTransactionIosParams>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroFinishTransactionIosParams get_std__optional_NitroFinishTransactionIosParams_(const std::optional<NitroFinishTransactionIosParams>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NitroFinishTransactionAndroidParams>
  /**
   * Specialized version of `std::optional<NitroFinishTransactionAndroidParams>`.
   */
  using std__optional_NitroFinishTransactionAndroidParams_ = std::optional<NitroFinishTransactionAndroidParams>;
  inline std::optional<NitroFinishTransactionAndroidParams> create_std__optional_NitroFinishTransactionAndroidParams_(const NitroFinishTransactionAndroidParams& value) noexcept {
    return std::optional<NitroFinishTransactionAndroidParams>(value);
  }
  inline bool has_value_std__optional_NitroFinishTransactionAndroidParams_(const std::optional<NitroFinishTransactionAndroidParams>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroFinishTransactionAndroidParams get_std__optional_NitroFinishTransactionAndroidParams_(const std::optional<NitroFinishTransactionAndroidParams>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const NitroPurchase& /* purchase */)>
  /**
   * Specialized version of `std::function<void(const NitroPurchase&)>`.
   */
  using Func_void_NitroPurchase = std::function<void(const NitroPurchase& /* purchase */)>;
  /**
   * Wrapper class for a `std::function<void(const NitroPurchase& / * purchase * /)>`, this can be used from Swift.
   */
  class Func_void_NitroPurchase_Wrapper final {
  public:
    explicit Func_void_NitroPurchase_Wrapper(std::function<void(const NitroPurchase& /* purchase */)>&& func): _function(std::make_unique<std::function<void(const NitroPurchase& /* purchase */)>>(std::move(func))) {}
    inline void call(NitroPurchase purchase) const noexcept {
      _function->operator()(purchase);
    }
  private:
    std::unique_ptr<std::function<void(const NitroPurchase& /* purchase */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_NitroPurchase create_Func_void_NitroPurchase(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_NitroPurchase_Wrapper wrap_Func_void_NitroPurchase(Func_void_NitroPurchase value) noexcept {
    return Func_void_NitroPurchase_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const NitroPurchaseResult& /* error */)>
  /**
   * Specialized version of `std::function<void(const NitroPurchaseResult&)>`.
   */
  using Func_void_NitroPurchaseResult = std::function<void(const NitroPurchaseResult& /* error */)>;
  /**
   * Wrapper class for a `std::function<void(const NitroPurchaseResult& / * error * /)>`, this can be used from Swift.
   */
  class Func_void_NitroPurchaseResult_Wrapper final {
  public:
    explicit Func_void_NitroPurchaseResult_Wrapper(std::function<void(const NitroPurchaseResult& /* error */)>&& func): _function(std::make_unique<std::function<void(const NitroPurchaseResult& /* error */)>>(std::move(func))) {}
    inline void call(NitroPurchaseResult error) const noexcept {
      _function->operator()(error);
    }
  private:
    std::unique_ptr<std::function<void(const NitroPurchaseResult& /* error */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_NitroPurchaseResult create_Func_void_NitroPurchaseResult(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_NitroPurchaseResult_Wrapper wrap_Func_void_NitroPurchaseResult(Func_void_NitroPurchaseResult value) noexcept {
    return Func_void_NitroPurchaseResult_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const NitroProduct& /* product */)>
  /**
   * Specialized version of `std::function<void(const NitroProduct&)>`.
   */
  using Func_void_NitroProduct = std::function<void(const NitroProduct& /* product */)>;
  /**
   * Wrapper class for a `std::function<void(const NitroProduct& / * product * /)>`, this can be used from Swift.
   */
  class Func_void_NitroProduct_Wrapper final {
  public:
    explicit Func_void_NitroProduct_Wrapper(std::function<void(const NitroProduct& /* product */)>&& func): _function(std::make_unique<std::function<void(const NitroProduct& /* product */)>>(std::move(func))) {}
    inline void call(NitroProduct product) const noexcept {
      _function->operator()(product);
    }
  private:
    std::unique_ptr<std::function<void(const NitroProduct& /* product */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_NitroProduct create_Func_void_NitroProduct(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_NitroProduct_Wrapper wrap_Func_void_NitroProduct(Func_void_NitroProduct value) noexcept {
    return Func_void_NitroProduct_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::string>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::string>>`.
   */
  using std__shared_ptr_Promise_std__string__ = std::shared_ptr<Promise<std::string>>;
  inline std::shared_ptr<Promise<std::string>> create_std__shared_ptr_Promise_std__string__() noexcept {
    return Promise<std::string>::create();
  }
  inline PromiseHolder<std::string> wrap_std__shared_ptr_Promise_std__string__(std::shared_ptr<Promise<std::string>> promise) noexcept {
    return PromiseHolder<std::string>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::string& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::string&)>`.
   */
  using Func_void_std__string = std::function<void(const std::string& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::string& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__string_Wrapper final {
  public:
    explicit Func_void_std__string_Wrapper(std::function<void(const std::string& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::string& /* result */)>>(std::move(func))) {}
    inline void call(std::string result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::string& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__string create_Func_void_std__string(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_std__string_Wrapper wrap_Func_void_std__string(Func_void_std__string value) noexcept {
    return Func_void_std__string_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::optional<std::string>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::optional<std::string>>>`.
   */
  using std__shared_ptr_Promise_std__optional_std__string___ = std::shared_ptr<Promise<std::optional<std::string>>>;
  inline std::shared_ptr<Promise<std::optional<std::string>>> create_std__shared_ptr_Promise_std__optional_std__string___() noexcept {
    return Promise<std::optional<std::string>>::create();
  }
  inline PromiseHolder<std::optional<std::string>> wrap_std__shared_ptr_Promise_std__optional_std__string___(std::shared_ptr<Promise<std::optional<std::string>>> promise) noexcept {
    return PromiseHolder<std::optional<std::string>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::optional<std::string>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::optional<std::string>&)>`.
   */
  using Func_void_std__optional_std__string_ = std::function<void(const std::optional<std::string>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::optional<std::string>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__optional_std__string__Wrapper final {
  public:
    explicit Func_void_std__optional_std__string__Wrapper(std::function<void(const std::optional<std::string>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::optional<std::string>& /* result */)>>(std::move(func))) {}
    inline void call(std::optional<std::string> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::optional<std::string>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__optional_std__string_ create_Func_void_std__optional_std__string_(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_std__optional_std__string__Wrapper wrap_Func_void_std__optional_std__string_(Func_void_std__optional_std__string_ value) noexcept {
    return Func_void_std__optional_std__string__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<NitroProduct>
  /**
   * Specialized version of `std::optional<NitroProduct>`.
   */
  using std__optional_NitroProduct_ = std::optional<NitroProduct>;
  inline std::optional<NitroProduct> create_std__optional_NitroProduct_(const NitroProduct& value) noexcept {
    return std::optional<NitroProduct>(value);
  }
  inline bool has_value_std__optional_NitroProduct_(const std::optional<NitroProduct>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroProduct get_std__optional_NitroProduct_(const std::optional<NitroProduct>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::optional<NitroProduct>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::optional<NitroProduct>>>`.
   */
  using std__shared_ptr_Promise_std__optional_NitroProduct___ = std::shared_ptr<Promise<std::optional<NitroProduct>>>;
  inline std::shared_ptr<Promise<std::optional<NitroProduct>>> create_std__shared_ptr_Promise_std__optional_NitroProduct___() noexcept {
    return Promise<std::optional<NitroProduct>>::create();
  }
  inline PromiseHolder<std::optional<NitroProduct>> wrap_std__shared_ptr_Promise_std__optional_NitroProduct___(std::shared_ptr<Promise<std::optional<NitroProduct>>> promise) noexcept {
    return PromiseHolder<std::optional<NitroProduct>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::optional<NitroProduct>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::optional<NitroProduct>&)>`.
   */
  using Func_void_std__optional_NitroProduct_ = std::function<void(const std::optional<NitroProduct>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::optional<NitroProduct>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__optional_NitroProduct__Wrapper final {
  public:
    explicit Func_void_std__optional_NitroProduct__Wrapper(std::function<void(const std::optional<NitroProduct>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::optional<NitroProduct>& /* result */)>>(std::move(func))) {}
    inline void call(std::optional<NitroProduct> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::optional<NitroProduct>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__optional_NitroProduct_ create_Func_void_std__optional_NitroProduct_(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_std__optional_NitroProduct__Wrapper wrap_Func_void_std__optional_NitroProduct_(Func_void_std__optional_NitroProduct_ value) noexcept {
    return Func_void_std__optional_NitroProduct__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<void>>
  /**
   * Specialized version of `std::shared_ptr<Promise<void>>`.
   */
  using std__shared_ptr_Promise_void__ = std::shared_ptr<Promise<void>>;
  inline std::shared_ptr<Promise<void>> create_std__shared_ptr_Promise_void__() noexcept {
    return Promise<void>::create();
  }
  inline PromiseHolder<void> wrap_std__shared_ptr_Promise_void__(std::shared_ptr<Promise<void>> promise) noexcept {
    return PromiseHolder<void>(std::move(promise));
  }
  
  // pragma MARK: std::function<void()>
  /**
   * Specialized version of `std::function<void()>`.
   */
  using Func_void = std::function<void()>;
  /**
   * Wrapper class for a `std::function<void()>`, this can be used from Swift.
   */
  class Func_void_Wrapper final {
  public:
    explicit Func_void_Wrapper(std::function<void()>&& func): _function(std::make_unique<std::function<void()>>(std::move(func))) {}
    inline void call() const noexcept {
      _function->operator()();
    }
  private:
    std::unique_ptr<std::function<void()>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void create_Func_void(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_Wrapper wrap_Func_void(Func_void value) noexcept {
    return Func_void_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<NitroSubscriptionRenewalInfo>
  /**
   * Specialized version of `std::optional<NitroSubscriptionRenewalInfo>`.
   */
  using std__optional_NitroSubscriptionRenewalInfo_ = std::optional<NitroSubscriptionRenewalInfo>;
  inline std::optional<NitroSubscriptionRenewalInfo> create_std__optional_NitroSubscriptionRenewalInfo_(const NitroSubscriptionRenewalInfo& value) noexcept {
    return std::optional<NitroSubscriptionRenewalInfo>(value);
  }
  inline bool has_value_std__optional_NitroSubscriptionRenewalInfo_(const std::optional<NitroSubscriptionRenewalInfo>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroSubscriptionRenewalInfo get_std__optional_NitroSubscriptionRenewalInfo_(const std::optional<NitroSubscriptionRenewalInfo>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<NitroSubscriptionStatus>
  /**
   * Specialized version of `std::vector<NitroSubscriptionStatus>`.
   */
  using std__vector_NitroSubscriptionStatus_ = std::vector<NitroSubscriptionStatus>;
  inline std::vector<NitroSubscriptionStatus> create_std__vector_NitroSubscriptionStatus_(size_t size) noexcept {
    std::vector<NitroSubscriptionStatus> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<NitroSubscriptionStatus>>
  /**
   * Specialized version of `std::optional<std::vector<NitroSubscriptionStatus>>`.
   */
  using std__optional_std__vector_NitroSubscriptionStatus__ = std::optional<std::vector<NitroSubscriptionStatus>>;
  inline std::optional<std::vector<NitroSubscriptionStatus>> create_std__optional_std__vector_NitroSubscriptionStatus__(const std::vector<NitroSubscriptionStatus>& value) noexcept {
    return std::optional<std::vector<NitroSubscriptionStatus>>(value);
  }
  inline bool has_value_std__optional_std__vector_NitroSubscriptionStatus__(const std::optional<std::vector<NitroSubscriptionStatus>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<NitroSubscriptionStatus> get_std__optional_std__vector_NitroSubscriptionStatus__(const std::optional<std::vector<NitroSubscriptionStatus>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::optional<std::vector<NitroSubscriptionStatus>>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::optional<std::vector<NitroSubscriptionStatus>>>>`.
   */
  using std__shared_ptr_Promise_std__optional_std__vector_NitroSubscriptionStatus____ = std::shared_ptr<Promise<std::optional<std::vector<NitroSubscriptionStatus>>>>;
  inline std::shared_ptr<Promise<std::optional<std::vector<NitroSubscriptionStatus>>>> create_std__shared_ptr_Promise_std__optional_std__vector_NitroSubscriptionStatus____() noexcept {
    return Promise<std::optional<std::vector<NitroSubscriptionStatus>>>::create();
  }
  inline PromiseHolder<std::optional<std::vector<NitroSubscriptionStatus>>> wrap_std__shared_ptr_Promise_std__optional_std__vector_NitroSubscriptionStatus____(std::shared_ptr<Promise<std::optional<std::vector<NitroSubscriptionStatus>>>> promise) noexcept {
    return PromiseHolder<std::optional<std::vector<NitroSubscriptionStatus>>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::optional<std::vector<NitroSubscriptionStatus>>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::optional<std::vector<NitroSubscriptionStatus>>&)>`.
   */
  using Func_void_std__optional_std__vector_NitroSubscriptionStatus__ = std::function<void(const std::optional<std::vector<NitroSubscriptionStatus>>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::optional<std::vector<NitroSubscriptionStatus>>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__optional_std__vector_NitroSubscriptionStatus___Wrapper final {
  public:
    explicit Func_void_std__optional_std__vector_NitroSubscriptionStatus___Wrapper(std::function<void(const std::optional<std::vector<NitroSubscriptionStatus>>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::optional<std::vector<NitroSubscriptionStatus>>& /* result */)>>(std::move(func))) {}
    inline void call(std::optional<std::vector<NitroSubscriptionStatus>> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::optional<std::vector<NitroSubscriptionStatus>>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__optional_std__vector_NitroSubscriptionStatus__ create_Func_void_std__optional_std__vector_NitroSubscriptionStatus__(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_std__optional_std__vector_NitroSubscriptionStatus___Wrapper wrap_Func_void_std__optional_std__vector_NitroSubscriptionStatus__(Func_void_std__optional_std__vector_NitroSubscriptionStatus__ value) noexcept {
    return Func_void_std__optional_std__vector_NitroSubscriptionStatus___Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<NitroPurchase>
  /**
   * Specialized version of `std::optional<NitroPurchase>`.
   */
  using std__optional_NitroPurchase_ = std::optional<NitroPurchase>;
  inline std::optional<NitroPurchase> create_std__optional_NitroPurchase_(const NitroPurchase& value) noexcept {
    return std::optional<NitroPurchase>(value);
  }
  inline bool has_value_std__optional_NitroPurchase_(const std::optional<NitroPurchase>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroPurchase get_std__optional_NitroPurchase_(const std::optional<NitroPurchase>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::optional<NitroPurchase>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::optional<NitroPurchase>>>`.
   */
  using std__shared_ptr_Promise_std__optional_NitroPurchase___ = std::shared_ptr<Promise<std::optional<NitroPurchase>>>;
  inline std::shared_ptr<Promise<std::optional<NitroPurchase>>> create_std__shared_ptr_Promise_std__optional_NitroPurchase___() noexcept {
    return Promise<std::optional<NitroPurchase>>::create();
  }
  inline PromiseHolder<std::optional<NitroPurchase>> wrap_std__shared_ptr_Promise_std__optional_NitroPurchase___(std::shared_ptr<Promise<std::optional<NitroPurchase>>> promise) noexcept {
    return PromiseHolder<std::optional<NitroPurchase>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::optional<NitroPurchase>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::optional<NitroPurchase>&)>`.
   */
  using Func_void_std__optional_NitroPurchase_ = std::function<void(const std::optional<NitroPurchase>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::optional<NitroPurchase>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__optional_NitroPurchase__Wrapper final {
  public:
    explicit Func_void_std__optional_NitroPurchase__Wrapper(std::function<void(const std::optional<NitroPurchase>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::optional<NitroPurchase>& /* result */)>>(std::move(func))) {}
    inline void call(std::optional<NitroPurchase> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::optional<NitroPurchase>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__optional_NitroPurchase_ create_Func_void_std__optional_NitroPurchase_(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_std__optional_NitroPurchase__Wrapper wrap_Func_void_std__optional_NitroPurchase_(Func_void_std__optional_NitroPurchase_ value) noexcept {
    return Func_void_std__optional_NitroPurchase__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>
  /**
   * Wrapper struct for `std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>`.
   * std::variant cannot be used in Swift because of a Swift bug.
   * Not even specializing it works. So we create a wrapper struct.
   */
  struct std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_ {
    std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid> variant;
    std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid> variant): variant(variant) { }
    operator std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>() const noexcept {
      return variant;
    }
    inline size_t index() const noexcept {
      return variant.index();
    }
    inline NitroReceiptValidationResultIOS get_0() const noexcept {
      return std::get<0>(variant);
    }
    inline NitroReceiptValidationResultAndroid get_1() const noexcept {
      return std::get<1>(variant);
    }
  };
  inline std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_ create_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(const NitroReceiptValidationResultIOS& value) noexcept {
    return std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(value);
  }
  inline std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_ create_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(const NitroReceiptValidationResultAndroid& value) noexcept {
    return std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>`.
   */
  using std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid___ = std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>;
  inline std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>> create_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid___() noexcept {
    return Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>::create();
  }
  inline PromiseHolder<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>> wrap_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid___(std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>> promise) noexcept {
    return PromiseHolder<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>&)>`.
   */
  using Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_ = std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid__Wrapper final {
  public:
    explicit Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid__Wrapper(std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>& /* result */)>>(std::move(func))) {}
    inline void call(std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_ create_Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(void* _Nonnull swiftClosureWrapper) noexcept;
  inline Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid__Wrapper wrap_Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_(Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid_ value) noexcept {
    return Func_void_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<NitroReceiptValidationAndroidOptions>
  /**
   * Specialized version of `std::optional<NitroReceiptValidationAndroidOptions>`.
   */
  using std__optional_NitroReceiptValidationAndroidOptions_ = std::optional<NitroReceiptValidationAndroidOptions>;
  inline std::optional<NitroReceiptValidationAndroidOptions> create_std__optional_NitroReceiptValidationAndroidOptions_(const NitroReceiptValidationAndroidOptions& value) noexcept {
    return std::optional<NitroReceiptValidationAndroidOptions>(value);
  }
  inline bool has_value_std__optional_NitroReceiptValidationAndroidOptions_(const std::optional<NitroReceiptValidationAndroidOptions>& optional) noexcept {
    return optional.has_value();
  }
  inline NitroReceiptValidationAndroidOptions get_std__optional_NitroReceiptValidationAndroidOptions_(const std::optional<NitroReceiptValidationAndroidOptions>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridRnIapSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridRnIapSpec>`.
   */
  using std__shared_ptr_HybridRnIapSpec_ = std::shared_ptr<HybridRnIapSpec>;
  std::shared_ptr<HybridRnIapSpec> create_std__shared_ptr_HybridRnIapSpec_(void* _Nonnull swiftUnsafePointer) noexcept;
  void* _Nonnull get_std__shared_ptr_HybridRnIapSpec_(std__shared_ptr_HybridRnIapSpec_ cppType) noexcept;
  
  // pragma MARK: std::weak_ptr<HybridRnIapSpec>
  using std__weak_ptr_HybridRnIapSpec_ = std::weak_ptr<HybridRnIapSpec>;
  inline std__weak_ptr_HybridRnIapSpec_ weakify_std__shared_ptr_HybridRnIapSpec_(const std::shared_ptr<HybridRnIapSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<Promise<bool>>>
  using Result_std__shared_ptr_Promise_bool___ = Result<std::shared_ptr<Promise<bool>>>;
  inline Result_std__shared_ptr_Promise_bool___ create_Result_std__shared_ptr_Promise_bool___(const std::shared_ptr<Promise<bool>>& value) noexcept {
    return Result<std::shared_ptr<Promise<bool>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_bool___ create_Result_std__shared_ptr_Promise_bool___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<bool>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<NitroProduct>>>>
  using Result_std__shared_ptr_Promise_std__vector_NitroProduct____ = Result<std::shared_ptr<Promise<std::vector<NitroProduct>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_NitroProduct____ create_Result_std__shared_ptr_Promise_std__vector_NitroProduct____(const std::shared_ptr<Promise<std::vector<NitroProduct>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<NitroProduct>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_NitroProduct____ create_Result_std__shared_ptr_Promise_std__vector_NitroProduct____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<NitroProduct>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<RequestPurchaseResult>>>
  using Result_std__shared_ptr_Promise_RequestPurchaseResult___ = Result<std::shared_ptr<Promise<RequestPurchaseResult>>>;
  inline Result_std__shared_ptr_Promise_RequestPurchaseResult___ create_Result_std__shared_ptr_Promise_RequestPurchaseResult___(const std::shared_ptr<Promise<RequestPurchaseResult>>& value) noexcept {
    return Result<std::shared_ptr<Promise<RequestPurchaseResult>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_RequestPurchaseResult___ create_Result_std__shared_ptr_Promise_RequestPurchaseResult___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<RequestPurchaseResult>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::vector<NitroPurchase>>>>
  using Result_std__shared_ptr_Promise_std__vector_NitroPurchase____ = Result<std::shared_ptr<Promise<std::vector<NitroPurchase>>>>;
  inline Result_std__shared_ptr_Promise_std__vector_NitroPurchase____ create_Result_std__shared_ptr_Promise_std__vector_NitroPurchase____(const std::shared_ptr<Promise<std::vector<NitroPurchase>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<NitroPurchase>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__vector_NitroPurchase____ create_Result_std__shared_ptr_Promise_std__vector_NitroPurchase____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::vector<NitroPurchase>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>>
  using Result_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult____ = Result<std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>>;
  inline Result_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult____ create_Result_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult____(const std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult____ create_Result_std__shared_ptr_Promise_std__variant_bool__NitroPurchaseResult____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>>>::withError(error);
  }
  
  // pragma MARK: Result<void>
  using Result_void_ = Result<void>;
  inline Result_void_ create_Result_void_() noexcept {
    return Result<void>::withValue();
  }
  inline Result_void_ create_Result_void_(const std::exception_ptr& error) noexcept {
    return Result<void>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::string>>>
  using Result_std__shared_ptr_Promise_std__string___ = Result<std::shared_ptr<Promise<std::string>>>;
  inline Result_std__shared_ptr_Promise_std__string___ create_Result_std__shared_ptr_Promise_std__string___(const std::shared_ptr<Promise<std::string>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::string>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__string___ create_Result_std__shared_ptr_Promise_std__string___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::string>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::optional<std::string>>>>
  using Result_std__shared_ptr_Promise_std__optional_std__string____ = Result<std::shared_ptr<Promise<std::optional<std::string>>>>;
  inline Result_std__shared_ptr_Promise_std__optional_std__string____ create_Result_std__shared_ptr_Promise_std__optional_std__string____(const std::shared_ptr<Promise<std::optional<std::string>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<std::string>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__optional_std__string____ create_Result_std__shared_ptr_Promise_std__optional_std__string____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<std::string>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::optional<NitroProduct>>>>
  using Result_std__shared_ptr_Promise_std__optional_NitroProduct____ = Result<std::shared_ptr<Promise<std::optional<NitroProduct>>>>;
  inline Result_std__shared_ptr_Promise_std__optional_NitroProduct____ create_Result_std__shared_ptr_Promise_std__optional_NitroProduct____(const std::shared_ptr<Promise<std::optional<NitroProduct>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<NitroProduct>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__optional_NitroProduct____ create_Result_std__shared_ptr_Promise_std__optional_NitroProduct____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<NitroProduct>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<void>>>
  using Result_std__shared_ptr_Promise_void___ = Result<std::shared_ptr<Promise<void>>>;
  inline Result_std__shared_ptr_Promise_void___ create_Result_std__shared_ptr_Promise_void___(const std::shared_ptr<Promise<void>>& value) noexcept {
    return Result<std::shared_ptr<Promise<void>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_void___ create_Result_std__shared_ptr_Promise_void___(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<void>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::optional<std::vector<NitroSubscriptionStatus>>>>>
  using Result_std__shared_ptr_Promise_std__optional_std__vector_NitroSubscriptionStatus_____ = Result<std::shared_ptr<Promise<std::optional<std::vector<NitroSubscriptionStatus>>>>>;
  inline Result_std__shared_ptr_Promise_std__optional_std__vector_NitroSubscriptionStatus_____ create_Result_std__shared_ptr_Promise_std__optional_std__vector_NitroSubscriptionStatus_____(const std::shared_ptr<Promise<std::optional<std::vector<NitroSubscriptionStatus>>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<std::vector<NitroSubscriptionStatus>>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__optional_std__vector_NitroSubscriptionStatus_____ create_Result_std__shared_ptr_Promise_std__optional_std__vector_NitroSubscriptionStatus_____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<std::vector<NitroSubscriptionStatus>>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::optional<NitroPurchase>>>>
  using Result_std__shared_ptr_Promise_std__optional_NitroPurchase____ = Result<std::shared_ptr<Promise<std::optional<NitroPurchase>>>>;
  inline Result_std__shared_ptr_Promise_std__optional_NitroPurchase____ create_Result_std__shared_ptr_Promise_std__optional_NitroPurchase____(const std::shared_ptr<Promise<std::optional<NitroPurchase>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<NitroPurchase>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__optional_NitroPurchase____ create_Result_std__shared_ptr_Promise_std__optional_NitroPurchase____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<NitroPurchase>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>>
  using Result_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid____ = Result<std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>>;
  inline Result_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid____ create_Result_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid____(const std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid____ create_Result_std__shared_ptr_Promise_std__variant_NitroReceiptValidationResultIOS__NitroReceiptValidationResultAndroid____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>>>::withError(error);
  }

} // namespace margelo::nitro::iap::bridge::swift
